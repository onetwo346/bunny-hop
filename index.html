<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hop Hop Bunny</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #87CEEB, #E0FFFF);
        }
        canvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <script>
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.score = 0;
                this.carrots = 0;
                this.isJumping = false;
                this.isCrouching = false;
                this.lastGroundTime = 0;
                this.hopTimer = 0;
                this.blinkFrame = 0;
                this.earTwitchFrame = 0;
                this.tailWagFrame = 0;
                this.runSpeed = 0;
                this.coyoteTime = 100;
                this.hopInterval = 300; // Time between micro-hops (ms)
            }

            init(data) {
                this.difficulty = data.difficulty || 2;
                const difficultySettings = {
                    1: { speed: 300, obstacleDelay: 3000, carrotDelay: 4000, platformDelay: 5000, wallDelay: 4000 },
                    2: { speed: 400, obstacleDelay: 2000, carrotDelay: 3000, platformDelay: 4000, wallDelay: 3500 },
                    3: { speed: 500, obstacleDelay: 1500, carrotDelay: 2500, platformDelay: 3500, wallDelay: 3000 },
                    4: { speed: 600, obstacleDelay: 1200, carrotDelay: 2000, platformDelay: 3000, wallDelay: 2500 },
                    5: { speed: 700, obstacleDelay: 1000, carrotDelay: 1800, platformDelay: 2500, wallDelay: 2000 }
                };
                const settings = difficultySettings[this.difficulty];
                this.speed = settings.speed;
                this.obstacleDelay = settings.obstacleDelay;
                this.carrotDelay = settings.carrotDelay;
                this.platformDelay = settings.platformDelay;
                this.wallDelay = settings.wallDelay;
            }

            preload() {
                // No external assets; all graphics generated in create()
            }

            create() {
                // Initialize graphics
                this.backgroundGraphics = this.add.graphics();
                this.groundGraphics = this.add.graphics();
                this.bunnyGraphics = this.add.graphics();
                this.leftEarGraphics = this.add.graphics();
                this.rightEarGraphics = this.add.graphics();

                // Draw background
                this.drawBackground();

                // Initialize clouds
                this.clouds = [];
                for (let i = 0; i < 3; i++) {
                    this.spawnCloud();
                }

                // Create ground
                this.drawGround();
                this.ground = this.add.rectangle(400, 550, 800, 100, 0x00FF00).setAlpha(0);
                this.physics.add.existing(this.ground, true);

                // Create bunny
                this.bunny = this.add.container(100, 450);
                this.bunny.add([this.bunnyGraphics, this.leftEarGraphics, this.rightEarGraphics]);
                this.bunny.setSize(60, 80);
                this.physics.add.existing(this.bunny);
                this.bunny.body.setGravityY(1800); // Strong gravity for grounding
                this.bunny.body.setCollideWorldBounds(true);
                this.bunny.body.setMaxVelocityY(1200);
                this.bunny.body.setDragX(2000); // High drag for quick stops
                this.updateBunnyGraphics();

                // Create groups
                this.platforms = this.physics.add.group({ allowGravity: false, immovable: true });
                this.walls = this.physics.add.group({ allowGravity: false, immovable: true });
                this.obstacles = this.physics.add.group({ allowGravity: false });
                this.carrotsGroup = this.physics.add.group({ allowGravity: false });

                // Set up collisions
                this.physics.add.collider(this.bunny, this.ground);
                this.physics.add.collider(this.bunny, this.platforms);
                this.physics.add.collider(this.bunny, this.walls);
                this.physics.add.overlap(this.bunny, this.obstacles, this.checkObstacleCollision, null, this);
                this.physics.add.overlap(this.bunny, this.carrotsGroup, this.collectCarrot, null, this);

                // Input handling
                this.cursors = this.input.keyboard.createCursorKeys();
                this.input.on('pointerdown', this.handleJumpInput, this);
                this.input.keyboard.on('keydown-SPACE', this.handleJumpInput, this);

                // UI elements
                this.scoreText = this.add.text(16, 16, 'Score: 0', {
                    fontSize: '32px',
                    fill: '#000',
                    fontStyle: 'bold'
                });
                this.carrotText = this.add.text(16, 56, 'Carrots: 0', {
                    fontSize: '32px',
                    fill: '#000',
                    fontStyle: 'bold'
                });

                // Timed events
                this.time.addEvent({ delay: this.obstacleDelay, callback: this.spawnObstacle, callbackScope: this, loop: true });
                this.time.addEvent({ delay: this.carrotDelay, callback: this.spawnCarrot, callbackScope: this, loop: true });
                this.time.addEvent({ delay: this.platformDelay, callback: this.spawnPlatform, callbackScope: this, loop: true });
                this.time.addEvent({ delay: this.wallDelay, callback: this.spawnWall, callbackScope: this, loop: true });
                this.time.addEvent({ delay: 60, callback: this.updateAnimations, callbackScope: this, loop: true });
            }

            drawBackground() {
                this.backgroundGraphics.fillGradientStyle(0x87CEEB, 0x87CEEB, 0xE0FFFF, 0xE0FFFF, 1);
                this.backgroundGraphics.fillRect(0, 0, 800, 600);
                this.backgroundGraphics.fillStyle(0x6B7280, 0.8);
                for (let x = -400; x < 1200; x += 200) {
                    this.backgroundGraphics.fillTriangle(x, 500, x + 100, 400, x + 200, 500);
                }
                this.backgroundGraphics.fillStyle(0x2F855A, 0.9);
                for (let x = -400; x < 1200; x += 100) {
                    this.backgroundGraphics.fillEllipse(x, 480, 60, 40);
                }
            }

            drawGround() {
                this.groundGraphics.clear();
                this.groundGraphics.fillStyle(0x4A7043, 1);
                this.groundGraphics.fillRect(0, 500, 800, 100);
                this.groundGraphics.fillStyle(0x2E8B57, 1);
                for (let x = 0; x < 800; x += 20) {
                    this.groundGraphics.fillTriangle(x, 500, x + 5, 480, x + 10, 500);
                }
            }

            spawnCloud() {
                const cloud = this.add.graphics();
                cloud.fillStyle(0xFFFFFF, 0.8);
                cloud.fillEllipse(850, Phaser.Math.Between(50, 150), 60, 30);
                cloud.fillEllipse(870, Phaser.Math.Between(50, 150), 50, 25);
                this.clouds.push(cloud);
                this.tweens.add({
                    targets: cloud,
                    x: -100,
                    duration: 20000,
                    onComplete: () => {
                        if (cloud.active) {
                            cloud.destroy();
                            this.clouds = this.clouds.filter(c => c !== cloud);
                            this.spawnCloud();
                        }
                    }
                });
            }

            updateBunnyGraphics() {
                this.bunnyGraphics.clear();
                this.leftEarGraphics.clear();
                this.rightEarGraphics.clear();

                // Shadow
                const shadowScale = 1 + (this.bunny.body.touching.down ? 0.15 : Math.max(0, this.bunny.body.velocity.y / 1200));
                this.bunnyGraphics.fillStyle(0x000000, this.bunny.body.touching.down ? 0.5 : 0.2);
                this.bunnyGraphics.fillEllipse(0, 60, 70 * shadowScale, 15 / shadowScale);

                // Body with crouch and hop effects
                const crouchScale = this.isCrouching ? 0.8 : 1.0;
                const hopHeight = this.bunny.body.touching.down && !this.isJumping ? 5 * Math.sin(this.hopTimer / this.hopInterval * Math.PI) : 0;
                const bodyScaleX = this.runSpeed > 0 ? 1.15 : this.runSpeed < 0 ? 0.85 : 1;
                this.bunnyGraphics.fillStyle(0xD3D8DC, 1);
                this.bunnyGraphics.fillRoundedRect(-45 * bodyScaleX, (-40 + hopHeight) * crouchScale, 90 * bodyScaleX, 70 * crouchScale, 25);
                this.bunnyGraphics.fillStyle(0xF8F9FA, 1);
                this.bunnyGraphics.fillRoundedRect(-40 * bodyScaleX, (-35 + hopHeight) * crouchScale, 80 * bodyScaleX, 60 * crouchScale, 20);
                this.bunnyGraphics.lineStyle(1, 0xB0B7C0, 0.6);
                for (let x = -35; x <= 35; x += 10) {
                    this.bunnyGraphics.lineBetween(x * bodyScaleX, (-25 + hopHeight) * crouchScale, x * bodyScaleX + 5, (-15 + hopHeight) * crouchScale);
                }

                // Ears
                const earAngleBase = this.runSpeed !== 0 ? 15 * Math.sign(this.runSpeed) : 0;
                const earAngleLeft = this.earTwitchFrame === 1 ? earAngleBase - 20 : earAngleBase;
                const earAngleRight = this.earTwitchFrame === 2 ? earAngleBase + 20 : earAngleBase;
                this.leftEarGraphics.setAngle(earAngleLeft);
                this.rightEarGraphics.setAngle(earAngleRight);
                this.leftEarGraphics.fillGradientStyle(0xF8F9FA, 0xE8ECEF, 0xF8F9FA, 0xE8ECEF, 1);
                this.leftEarGraphics.fillEllipse(-30, -70 + hopHeight, 20, 50);
                this.leftEarGraphics.fillStyle(0xFFC1CC, 1);
                this.leftEarGraphics.fillEllipse(-30, -70 + hopHeight, 14, 40);
                this.rightEarGraphics.fillGradientStyle(0xF8F9FA, 0xE8ECEF, 0xF8F9FA, 0xE8ECEF, 1);
                this.rightEarGraphics.fillEllipse(30, -68 + hopHeight, 20, 50);
                this.rightEarGraphics.fillStyle(0xFFC1CC, 1);
                this.rightEarGraphics.fillEllipse(30, -68 + hopHeight, 14, 40);

                // Tail
                const tailOffset = this.tailWagFrame * 4 * (Math.abs(this.runSpeed) / 200);
                this.bunnyGraphics.fillGradientStyle(0xFFFFFF, 0xF8F9FA, 0xFFFFFF, 0xF8F9FA, 1);
                this.bunnyGraphics.fillCircle(-40 + tailOffset, (20 + hopHeight) * crouchScale, 18);
                this.bunnyGraphics.fillStyle(0xE8ECEF, 1);
                this.bunnyGraphics.fillCircle(-40 + tailOffset, (20 + hopHeight) * crouchScale, 14);

                // Legs with hopping animation
                const legHeightBase = this.isJumping ? 15 : 30;
                const legHop = this.bunny.body.touching.down ? 10 * Math.cos(this.hopTimer / this.hopInterval * Math.PI) : 0;
                this.bunnyGraphics.fillStyle(0xF8F9FA, 1);
                const legCycle = Math.floor(this.hopTimer / (this.hopInterval / 4)) % 4;
                const legPositions = [
                    { x1: -35, y1: 15, h1: legHeightBase + legHop, x2: 15, y2: 25, h2: legHeightBase + legHop - 10 },
                    { x1: 15, y1: 15, h1: legHeightBase + legHop, x2: -35, y2: 25, h2: legHeightBase + legHop - 10 },
                    { x1: -35, y1: 18, h1: legHeightBase + legHop - 3, x2: 15, y2: 28, h2: legHeightBase + legHop - 12 },
                    { x1: 15, y1: 18, h1: legHeightBase + legHop - 3, x2: -35, y2: 28, h2: legHeightBase + legHop - 12 }
                ];
                const pos = legPositions[legCycle];
                this.bunnyGraphics.fillRoundedRect(pos.x1 * bodyScaleX, (pos.y1 + hopHeight) * crouchScale, 20, pos.h1, 8);
                this.bunnyGraphics.fillRoundedRect(pos.x2 * bodyScaleX, (pos.y2 + hopHeight) * crouchScale, 20, pos.h2, 8);

                // Face
                this.bunnyGraphics.fillStyle(this.blinkFrame > 0 ? 0x000000 : 0x000000, 1);
                const eyeSize = Math.abs(this.runSpeed) > 10 ? 10 : 9;
                const eyeHeight = this.blinkFrame > 0 ? 4 : 9;
                this.bunnyGraphics.fillEllipse(-20, (-18 + hopHeight) * crouchScale, eyeSize, eyeHeight);
                this.bunnyGraphics.fillEllipse(20, (-18 + hopHeight) * crouchScale, eyeSize, eyeHeight);
                if (!this.blinkFrame) {
                    this.bunnyGraphics.fillStyle(0xFFFFFF, 1);
                    this.bunnyGraphics.fillCircle(-19, (-19 + hopHeight) * crouchScale, 3);
                    this.bunnyGraphics.fillCircle(21, (-19 + hopHeight) * crouchScale, 3);
                }
                this.bunnyGraphics.fillStyle(0xFFC1CC, 1);
                this.bunnyGraphics.fillTriangle(0, (-6 + hopHeight) * crouchScale, -7, (-3 + hopHeight) * crouchScale, 7, (-3 + hopHeight) * crouchScale);
                this.bunnyGraphics.fillEllipse(0, (-3 + hopHeight) * crouchScale, 14, 7);
                const whiskerAngle = this.runSpeed / 40;
                this.bunnyGraphics.lineStyle(1, 0xFFFFFF, 0.9);
                this.bunnyGraphics.lineBetween(-14, (-3 + hopHeight) * crouchScale, -35, (-3 + whiskerAngle + hopHeight) * crouchScale);
                this.bunnyGraphics.lineBetween(-14, (0 + hopHeight) * crouchScale, -33, (3 + whiskerAngle + hopHeight) * crouchScale);
                this.bunnyGraphics.lineBetween(14, (-3 + hopHeight) * crouchScale, 35, (-3 + whiskerAngle + hopHeight) * crouchScale);
                this.bunnyGraphics.lineBetween(14, (0 + hopHeight) * crouchScale, 33, (3 + whiskerAngle + hopHeight) * crouchScale);
            }

            updateAnimations() {
                this.blinkFrame = (this.time.now % 3600 < 120) ? 1 : 0;
                this.earTwitchFrame = (this.time.now % 3000 < 1000) ? Phaser.Math.Between(1, 2) : 0;
                this.tailWagFrame = (this.time.now % 600 < 200) ? Phaser.Math.Between(1, 2) : 0;
                this.updateBunnyGraphics();
            }

            handleJumpInput() {
                if (this.bunny.body.touching.down || (this.time.now - this.lastGroundTime < this.coyoteTime)) {
                    if (!this.isCrouching) {
                        // Start crouch animation
                        this.isCrouching = true;
                        this.tweens.add({
                            targets: this.bunny,
                            scaleY: 0.8,
                            duration: 100,
                            onComplete: () => {
                                if (this.bunny.active) {
                                    // Perform jump
                                    const jumpVelocity = -900 - Math.abs(this.runSpeed) * 0.2;
                                    this.bunny.body.setVelocityY(jumpVelocity);
                                    this.isJumping = true;
                                    this.isCrouching = false;
                                    this.tweens.add({
                                        targets: this.bunny,
                                        angle: this.runSpeed > 0 ? 45 : -45,
                                        scale: { x: 1.3, y: 0.8 },
                                        duration: 250,
                                        yoyo: true,
                                        onComplete: () => {
                                            if (this.bunny.active) {
                                                this.bunny.angle = 0;
                                                this.bunny.scale = 1;
                                            }
                                        }
                                    });
                                    // Dust effect
                                    for (let i = 0; i < 12; i++) {
                                        const dust = this.add.circle(this.bunny.x + Phaser.Math.Between(-20, 20), this.bunny.y + 25, 4, 0xA9A9A9, 0.5);
                                        this.tweens.add({
                                            targets: dust,
                                            x: dust.x + Phaser.Math.Between(-30, 30),
                                            y: dust.y + Phaser.Math.Between(15, 40),
                                            alpha: 0,
                                            duration: 500,
                                            onComplete: () => dust.active && dust.destroy()
                                        });
                                    }
                                }
                            }
                        });
                    }
                }
            }

            moveBunny(delta) {
                let accel = 0;
                if (this.cursors.right.isDown) {
                    accel = 1200 + Math.abs(this.bunny.body.velocity.x) * 0.2;
                    this.bunny.scaleX = 1;
                } else if (this.cursors.left.isDown) {
                    accel = -1200 - Math.abs(this.bunny.body.velocity.x) * 0.2;
                    this.bunny.scaleX = -1;
                } else {
                    this.bunny.body.setAccelerationX(0);
                    this.runSpeed = 0;
                }

                if (accel !== 0 && this.bunny.body.touching.down && !this.isJumping) {
                    this.bunny.body.setAccelerationX(accel);
                    this.runSpeed = Phaser.Math.Clamp(this.bunny.body.velocity.x, -this.speed, this.speed);
                    // Trigger micro-hops
                    this.hopTimer += delta;
                    if (this.hopTimer >= this.hopInterval) {
                        this.bunny.body.setVelocityY(-400); // Small hop
                        this.hopTimer = 0;
                    }
                } else {
                    this.hopTimer = Math.min(this.hopTimer + delta, this.hopInterval);
                }

                this.bunny.body.velocity.x = Phaser.Math.Clamp(this.bunny.body.velocity.x, -this.speed * 1.2, this.speed * 1.2);
            }

            spawnObstacle() {
                const obstacle = this.add.container(850, 500);
                const graphics = this.add.graphics();
                graphics.fillStyle(0x000000, 0.3);
                graphics.fillEllipse(0, 40, 60, 10);
                graphics.fillStyle(0x6B4E31, 1);
                graphics.fillRoundedRect(-35, -60, 70, 100, 20);
                graphics.lineStyle(2, 0x8B4513, 0.6);
                for (let y = -50; y < 30; y += 10) {
                    graphics.lineBetween(-20, y, 20, y + 5);
                }
                graphics.fillStyle(0x228B22, 0.7);
                graphics.fillEllipse(-25, -10, 15, 10);
                graphics.fillEllipse(20, 0, 10, 8);
                obstacle.add(graphics);
                obstacle.setSize(50, 90);
                this.physics.add.existing(obstacle);
                obstacle.body.setVelocityX(-200);
                obstacle.body.setAllowGravity(false);
                this.obstacles.add(obstacle);

                this.time.addEvent({
                    delay: 5000,
                    callback: () => obstacle.active && obstacle.destroy(),
                    callbackScope: this
                });
            }

            spawnCarrot() {
                const carrot = this.add.container(850, Phaser.Math.Between(200, 400));
                const graphics = this.add.graphics();
                graphics.fillStyle(0xFF8C00, 1);
                graphics.fillTriangle(0, -30, -15, 30, 15, 30);
                graphics.fillStyle(0x006400, 1);
                graphics.fillTriangle(-12, -40, -7, -25, -2, -35);
                graphics.fillTriangle(2, -40, 7, -25, 12, -35);
                carrot.add(graphics);
                carrot.setSize(30, 60);
                this.physics.add.existing(carrot);
                carrot.body.setVelocityX(-200);
                carrot.body.setAllowGravity(false);
                this.carrotsGroup.add(carrot);

                this.time.addEvent({
                    delay: 5000,
                    callback: () => carrot.active && carrot.destroy(),
                    callbackScope: this
                });
            }

            spawnPlatform() {
                const platform = this.add.container(850, Phaser.Math.Between(300, 450));
                const graphics = this.add.graphics();
                graphics.fillStyle(0x8B4513, 1);
                graphics.fillRect(-50, -20, 100, 40);
                platform.add(graphics);
                platform.setSize(100, 40);
                this.physics.add.existing(platform);
                platform.body.setVelocityX(-200);
                platform.body.setImmovable(true);
                this.platforms.add(platform);

                this.time.addEvent({
                    delay: 6000,
                    callback: () => platform.active && platform.destroy(),
                    callbackScope: this
                });
            }

            spawnWall() {
                const height = Phaser.Math.Between(100, 200);
                const wall = this.add.container(850, 500 - height / 2);
                const graphics = this.add.graphics();
                graphics.fillStyle(0x8B4513, 1);
                const brickHeight = 20;
                const brickWidth = 40;
                const wallWidth = 40;
                for (let h = 0; h < height; h += brickHeight) {
                    const offset = (h / brickHeight % 2) * (brickWidth / 2);
                    for (let w = -wallWidth / 2; w < wallWidth / 2; w += brickWidth) {
                        graphics.fillRect(w + offset, h - height / 2, brickWidth, brickHeight);
                    }
                }
                wall.add(graphics);
                wall.setSize(wallWidth, height);
                this.physics.add.existing(wall);
                wall.body.setVelocityX(-200);
                wall.body.setImmovable(true);
                this.walls.add(wall);

                this.time.addEvent({
                    delay: 6000,
                    callback: () => wall.active && wall.destroy(),
                    callbackScope: this
                });
            }

            collectCarrot(bunny, carrot) {
                if (!carrot.active) return;
                const carrotX = carrot.x;
                const carrotY = carrot.y;
                carrot.destroy();
                this.carrots++;
                this.carrotText.setText('Carrots: ' + this.carrots);

                const sparkle = this.add.graphics().setPosition(carrotX, carrotY);
                sparkle.fillStyle(0xFFD700, 1);
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const distance = Phaser.Math.Between(5, 15);
                    sparkle.fillCircle(Math.cos(angle) * distance, Math.sin(angle) * distance, 3);
                }
                this.tweens.add({
                    targets: sparkle,
                    alpha: 0,
                    scale: 1.5,
                    duration: 500,
                    onComplete: () => sparkle.active && sparkle.destroy()
                });

                const tints = [
                    { carrots: 5, color: 0xFF6B6B },
                    { carrots: 10, color: 0x343A40 },
                    { carrots: 15, color: 0xFF8FAB }
                ];
                const tint = tints.find(t => t.carrots === this.carrots);
                if (tint) {
                    this.bunnyGraphics.setTint(tint.color);
                    this.leftEarGraphics.setTint(tint.color);
                    this.rightEarGraphics.setTint(tint.color);
                }
            }

            checkObstacleCollision(bunny, obstacle) {
                if (!bunny.active || !obstacle.active) return;
                const collisionY = bunny.y + bunny.body.height / 2;
                const obstacleTopY = obstacle.y - obstacle.body.height / 2;
                if (collisionY > obstacleTopY + 30) {
                    this.gameOver();
                }
            }

            gameOver() {
                this.physics.pause();
                this.scene.start('GameOverScene', {
                    score: this.score,
                    carrots: this.carrots,
                    difficulty: this.difficulty
                });
            }

            update(time, delta) {
                if (this.bunny.body.touching.down) {
                    this.lastGroundTime = time;
                    if (this.isJumping) {
                        this.isJumping = false;
                        this.tweens.add({
                            targets: this.bunny,
                            y: this.bunny.y + 15,
                            scale: { x: 1.2, y: 0.8 },
                            duration: 150,
                            yoyo: true,
                            onComplete: () => this.bunny.active && (this.bunny.scale = 1)
                        });
                    }
                }

                this.moveBunny(delta);

                if (!this.bunny.body.touching.down) {
                    this.score += delta / 1000 * 10;
                    this.scoreText.setText('Score: ' + Math.floor(this.score));
                }

                this.backgroundGraphics.x -= 0.5;
                if (this.backgroundGraphics.x < -400) this.backgroundGraphics.x += 800;
                this.drawGround();
            }
        }

        class IntroScene extends Phaser.Scene {
            constructor() {
                super({ key: 'IntroScene' });
            }

            create() {
                const sky = this.add.graphics();
                sky.fillGradientStyle(0x1a73e8, 0x174ea6, 0x174ea6, 0x1a73e8, 1);
                sky.fillRect(0, 0, 800, 600);

                for (let i = 0; i < 5; i++) {
                    const cloud = this.add.graphics();
                    cloud.fillStyle(0xffffff, 0.8);
                    const x = Phaser.Math.Between(0, 800);
                    const y = Phaser.Math.Between(50, 200);
                    cloud.fillCircle(x, y, 30);
                    cloud.fillCircle(x + 20, y - 10, 25);
                    cloud.fillCircle(x - 20, y - 5, 25);
                    this.tweens.add({
                        targets: cloud,
                        x: '+=20',
                        yoyo: true,
                        duration: 2000 + i * 500,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                }

                const bunny = this.add.graphics().setPosition(400, 200);
                bunny.fillStyle(0xFFFFFF, 1);
                bunny.fillCircle(0, 0, 40);
                bunny.fillCircle(-20, -50, 15);
                bunny.fillCircle(20, -50, 15);
                bunny.fillStyle(0xFF69B4, 1);
                bunny.fillCircle(-10, -10, 5);
                bunny.lineStyle(2, 0x000000, 1);
                bunny.strokeCircle(-20, -15, 8);
                bunny.strokeCircle(20, -15, 8);

                this.add.text(400, 100, 'Bunny Hop', {
                    fontSize: '72px',
                    fontFamily: 'Arial Black',
                    color: '#fff',
                    stroke: '#4a90e2',
                    strokeThickness: 16,
                    shadow: { color: '#4a90e2', blur: 25, stroke: true, fill: true }
                }).setOrigin(0.5);

                const controlsBox = this.add.graphics();
                controlsBox.fillStyle(0x000000, 0.3);
                controlsBox.fillRoundedRect(200, 260, 400, 160, 20);

                this.add.text(400, 340, ['ðŸŽ® Controls', '', 'âŒ¨ï¸ Space/Click - Jump', 'âŒ¨ï¸ Left/Right - Move', '', 'ðŸ¥• Collect carrots!'].join('\n'), {
                    fontSize: '24px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    align: 'center',
                    lineSpacing: 15
                }).setOrigin(0.5);

                const startButton = this.add.graphics().setPosition(400, 520);
                startButton.lineStyle(4, 0xFFFFFF, 1);
                startButton.fillStyle(0x0d47a1, 0.9);
                startButton.fillRoundedRect(-120, -30, 240, 60, 30);
                startButton.strokeRoundedRect(-120, -30, 240, 60, 30);

                const startText = this.add.text(400, 520, 'TAP TO BEGIN', {
                    fontSize: '32px',
                    fontFamily: 'Arial Black',
                    color: '#fff',
                    stroke: '#1565c0',
                    strokeThickness: 6
                }).setOrigin(0.5);

                startButton.setInteractive(new Phaser.Geom.Rectangle(-100, -25, 200, 50), Phaser.Geom.Rectangle.Contains);
                startText.setInteractive();

                const startGame = () => this.scene.start('OptionsScene');
                startButton.on('pointerdown', startGame);
                startText.on('pointerdown', startGame);

                this.input.on('pointerdown', startGame);
                this.input.keyboard.on('keydown-SPACE', startGame);
                this.input.keyboard.on('keydown-ENTER', startGame);
            }
        }

        class OptionsScene extends Phaser.Scene {
            constructor() {
                super({ key: 'OptionsScene' });
            }

            create() {
                const sky = this.add.graphics();
                sky.fillGradientStyle(0x1a73e8, 0x174ea6, 0x174ea6, 0x1a73e8, 1);
                sky.fillRect(0, 0, 800, 600);

                for (let i = 0; i < 5; i++) {
                    const cloud = this.add.graphics();
                    cloud.fillStyle(0xffffff, 0.8);
                    const x = Phaser.Math.Between(0, 800);
                    const y = Phaser.Math.Between(50, 200);
                    cloud.fillCircle(x, y, 30);
                    cloud.fillCircle(x + 20, y -10, 25);
                    cloud.fillCircle(x - 20, y - 5, 25);
                    this.tweens.add({
                        targets: cloud,
                        x: '+=20',
                        yoyo: true,
                        duration: 2000 + i * 500,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                }

                this.add.text(400, 100, 'Select Difficulty', {
                    fontSize: '48px',
                    fontFamily: 'Arial Black',
                    color: '#fff',
                    stroke: '#4a90e2',
                    strokeThickness: 12,
                    shadow: { color: '#4a90e2', blur: 20, stroke: true, fill: true }
                }).setOrigin(0.5);

                const difficulties = [
                    { level: 1, name: 'Easy Hop', color: 0x4CAF50, desc: 'Perfect for beginners' },
                    { level: 2, name: 'Normal Bounce', color: 0x2196F3, desc: 'Standard challenge' },
                    { level: 3, name: 'Hard Jump', color: 0xFFC107, desc: 'For skilled players' },
                    { level: 4, name: 'Expert Leap', color: 0xFF5722, desc: 'Intense challenge' },
                    { level: 5, name: 'Master Spring', color: 0x9C27B0, desc: 'Ultimate test' }
                ];

                difficulties.forEach((diff, index) => {
                    const y = 230 + index * 70;
                    const button = this.add.graphics().setPosition(400, y);
                    button.lineStyle(3, 0xFFFFFF, 0.8);
                    button.fillStyle(diff.color, 0.2);
                    button.fillRoundedRect(-160, -25, 320, 50, 15);
                    button.strokeRoundedRect(-160, -25, 320, 50, 15);

                    const text = this.add.text(400, y - 10, diff.name, {
                        fontSize: '24px',
                        fontFamily: 'Arial Black',
                        color: '#fff',
                        stroke: '#000',
                        strokeThickness: 4
                    }).setOrigin(0.5);

                    const desc = this.add.text(400, y + 15, diff.desc, {
                        fontSize: '16px',
                        fontFamily: 'Arial',
                        color: '#ccc'
                    }).setOrigin(0.5);

                    button.setInteractive(new Phaser.Geom.Rectangle(-160, -25, 320, 50), Phaser.Geom.Rectangle.Contains)
                        .on('pointerover', () => {
                            button.clear();
                            button.lineStyle(3, 0xFFFFFF, 1);
                            button.fillStyle(diff.color, 0.4);
                            button.fillRoundedRect(-160, -25, 320, 50, 15);
                            button.strokeRoundedRect(-160, -25, 320, 50, 15);
                            text.setScale(1.05);
                            desc.setScale(1.05);
                        })
                        .on('pointerout', () => {
                            button.clear();
                            button.lineStyle(3, 0xFFFFFF, 0.8);
                            button.fillStyle(diff.color, 0.2);
                            button.fillRoundedRect(-160, -25, 320, 50, 15);
                            button.strokeRoundedRect(-160, -25, 320, 50, 15);
                            text.setScale(1);
                            desc.setScale(1);
                        })
                        .on('pointerdown', () => {
                            this.cameras.main.fade(500, 0, 0, 0);
                            this.time.delayedCall(500, () => this.scene.start('GameScene', { difficulty: diff.level }));
                        });
                });
            }
        }

        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
            }

            init(data) {
                this.score = data.score;
                this.carrots = data.carrots;
                this.difficulty = data.difficulty;
            }

            create() {
                const sky = this.add.graphics();
                sky.fillGradientStyle(0x87CEEB, 0x87CEEB, 0xE0FFFF, 0xE0FFFF, 1);
                sky.fillRect(0, 0, 800, 600);

                this.add.text(400, 150, 'Game Over!', {
                    fontSize: '64px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    stroke: '#000',
                    strokeThickness: 6,
                    shadow: { color: '#000', blur: 10, stroke: true, fill: true }
                }).setOrigin(0.5);

                this.add.text(400, 250, `Score: ${Math.floor(this.score)}\nCarrots: ${this.carrots}`, {
                    fontSize: '32px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    stroke: '#000',
                    strokeThickness: 4,
                    align: 'center',
                    lineSpacing: 10
                }).setOrigin(0.5);

                const buttonStyle = {
                    fontSize: '32px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    stroke: '#000',
                    strokeThickness: 4,
                    backgroundColor: '#4CAF50',
                    padding: { x: 20, y: 10 }
                };

                const replayButton = this.add.text(400, 350, 'Replay Level', buttonStyle)
                    .setOrigin(0.5)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => replayButton.setScale(1.1))
                    .on('pointerout', () => replayButton.setScale(1))
                    .on('pointerdown', () => this.scene.start('GameScene', { difficulty: this.difficulty }));

                const optionsButton = this.add.text(400, 420, 'Try Different Level', buttonStyle)
                    .setOrigin(0.5)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => optionsButton.setScale(1.1))
                    .on('pointerout', () => optionsButton.setScale(1))
                    .on('pointerdown', () => this.scene.start('OptionsScene'));
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            backgroundColor: '#87CEEB',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false,
                    tileBias: 40,
                    fps: 60
                }
            },
            scene: [IntroScene, OptionsScene, GameScene, GameOverScene]
        };

        new Phaser.Game(config);
    </script>
</body>
</html>
