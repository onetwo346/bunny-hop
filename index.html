<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hop Hop Bunny</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #87CEEB, #E0FFFF);
        }
        canvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <script>
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.score = 0;
                this.carrots = 0;
                this.groundOffset = 0;
                this.isJumping = false;
                this.isCrouching = false;
                this.lastGroundTime = 0;
                this.hopFrame = 0; // Tracks hopping cycle
                this.hopPhase = 0; // Normalized [0, 1]
                this.blinkFrame = 0;
                this.noseTwitchFrame = 0;
                this.earFlopFrame = 0;
                this.tailFlickFrame = 0;
                this.crouchTime = 0;
                this.runSpeed = 0;
                this.coyoteTime = 150; // More forgiving
                this.hopSpeed = 0.25; // Base hop cycle speed
            }

            init(data) {
                this.difficulty = data.difficulty || 2;
                const difficultySettings = {
                    1: { speed: 300, obstacleDelay: 3000, carrotDelay: 4000, platformDelay: 5000 },
                    2: { speed: 400, obstacleDelay: 2000, carrotDelay: 3000, platformDelay: 4000 },
                    3: { speed: 500, obstacleDelay: 1500, carrotDelay: 2500, platformDelay: 3500 },
                    4: { speed: 600, obstacleDelay: 1200, carrotDelay: 2000, platformDelay: 3000 },
                    5: { speed: 700, obstacleDelay: 1000, carrotDelay: 1800, platformDelay: 2500 }
                };
                const settings = difficultySettings[this.difficulty];
                this.speed = settings.speed;
                this.obstacleDelay = settings.obstacleDelay;
                this.carrotDelay = settings.carrotDelay;
                this.platformDelay = settings.platformDelay;
            }

            preload() {
                // No external assets
            }

            create() {
                // Graphics objects
                this.skyGraphics = this.add.graphics();
                this.hillsGraphics = this.add.graphics();
                this.bushesGraphics = this.add.graphics();
                this.groundGraphics = this.add.graphics();
                this.bunnyGraphics = this.add.graphics();
                this.leftEarGraphics = this.add.graphics();
                this.rightEarGraphics = this.add.graphics();

                // Background
                this.drawSky();
                this.drawBackground();

                // Clouds
                this.clouds = [];
                for (let i = 0; i < 3; i++) {
                    this.spawnCloud();
                }

                // Ground
                this.drawGround();
                this.ground = this.add.rectangle(400, 550, 800, 100, 0x00FF00).setAlpha(0);
                this.physics.add.existing(this.ground, true);

                // Bunny
                this.bunny = this.add.container(100, 300);
                this.bunny.add([this.bunnyGraphics, this.leftEarGraphics, this.rightEarGraphics]);
                this.bunny.setSize(60, 80);
                this.physics.add.existing(this.bunny);
                this.bunny.body.setGravityY(2000); // Tighter gravity
                this.bunny.body.setCollideWorldBounds(true);
                this.bunny.body.setMaxVelocityY(1200);
                this.bunny.body.setDragX(3000); // Snappy stops
                this.updateBunnyGraphics();

                // Groups
                this.platforms = this.physics.add.group({
                    allowGravity: false,
                    immovable: true
                });
                this.walls = this.physics.add.group({
                    allowGravity: false,
                    immovable: true
                });

                // Collisions
                this.physics.add.collider(this.bunny, this.ground);
                this.physics.add.collider(this.bunny, this.platforms);
                this.physics.add.collider(this.bunny, this.walls);

                // Input
                this.cursors = this.input.keyboard.createCursorKeys();
                this.input.on('pointerdown', this.initiateJump, this);
                this.input.keyboard.on('keydown-SPACE', this.initiateJump, this);

                // UI
                this.scoreText = this.add.text(16, 16, 'Score: 0', {
                    fontSize: '32px',
                    fill: '#000',
                    fontStyle: 'bold'
                });
                this.carrotText = this.add.text(16, 56, 'Carrots: 0', {
                    fontSize: '32px',
                    fill: '#000',
                    fontStyle: 'bold'
                });

                // Events
                this.time.addEvent({
                    delay: this.obstacleDelay,
                    callback: this.spawnObstacle,
                    callbackScope: this,
                    loop: true
                });
                this.time.addEvent({
                    delay: this.carrotDelay,
                    callback: this.spawnCarrot,
                    callbackScope: this,
                    loop: true
                });
                this.time.addEvent({
                    delay: this.platformDelay,
                    callback: this.spawnPlatform,
                    callbackScope: this,
                    loop: true
                });
                this.time.addEvent({
                    delay: 4000,
                    callback: this.spawnWall,
                    callbackScope: this,
                    loop: true
                });
                this.time.addEvent({
                    delay: 20, // Ultra-smooth animations
                    callback: this.updateAnimations,
                    callbackScope: this,
                    loop: true
                });
            }

            drawSky() {
                this.skyGraphics.fillGradientStyle(0x87CEEB, 0x87CEEB, 0xE0FFFF, 0xE0FFFF, 1);
                this.skyGraphics.fillRect(0, 0, 800, 600);
            }

            spawnCloud() {
                try {
                    const cloud = this.add.graphics();
                    cloud.fillStyle(0xFFFFFF, 0.8);
                    cloud.fillEllipse(850, Phaser.Math.Between(50, 150), 60, 30);
                    cloud.fillEllipse(870, Phaser.Math.Between(50, 150), 50, 25);
                    this.clouds.push(cloud);
                    this.tweens.add({
                        targets: cloud,
                        x: -100,
                        duration: 20000,
                        onComplete: () => {
                            if (cloud && cloud.active) {
                                cloud.destroy();
                                this.clouds = this.clouds.filter(c => c !== cloud);
                                this.spawnCloud();
                            }
                        }
                    });
                } catch (error) {
                    console.warn('Error spawning cloud:', error);
                }
            }

            drawBackground() {
                this.hillsGraphics.fillStyle(0x6B7280, 0.8);
                for (let x = -400; x < 1200; x += 200) {
                    this.hillsGraphics.fillTriangle(x, 500, x + 100, 400, x + 200, 500);
                }
                this.bushesGraphics.fillStyle(0x2F855A, 0.9);
                for (let x = -400; x < 1200; x += 100) {
                    this.bushesGraphics.fillEllipse(x, 480, 60, 40);
                }
            }

            drawGround() {
                this.groundGraphics.clear();
                this.groundGraphics.fillStyle(0x4A7043, 1);
                this.groundGraphics.fillRect(0, 500, 800, 100);
                this.groundGraphics.fillStyle(0x2E8B57, 1);
                for (let x = -this.groundOffset % 20; x < 800; x += 20) {
                    this.groundGraphics.fillTriangle(x, 500, x + 5, 480, x + 10, 500);
                }
            }

            updateBunnyGraphics() {
                this.bunnyGraphics.clear();
                this.leftEarGraphics.clear();
                this.rightEarGraphics.clear();

                // Shadow
                const shadowScale = 1 + (this.bunny.body.touching.down ? 0.25 : Math.max(0, this.bunny.body.velocity.y / 1200));
                this.bunnyGraphics.fillStyle(0x000000, this.bunny.body.touching.down ? 0.6 : 0.3);
                this.bunnyGraphics.fillEllipse(0, 65, 80 * shadowScale, 15 / shadowScale);

                // Hop and crouch
                let hopHeight = 0;
                let bodyScaleY = 1;
                let bodyScaleX = 1;
                let breathingOffset = 0;
                if (this.bunny.body.touching.down && !this.isJumping) {
                    if (this.isCrouching) {
                        bodyScaleY = 0.75;
                        bodyScaleX = 1.15;
                        hopHeight = 15;
                    } else {
                        hopHeight = 15 * Math.sin(this.hopPhase * 2 * Math.PI); // Snappy hop
                        bodyScaleY = 1 + 0.06 * Math.cos(this.hopPhase * 2 * Math.PI);
                        bodyScaleX = Math.abs(this.runSpeed) > 50 ? 1.12 : 1.05;
                        breathingOffset = Math.abs(this.runSpeed) < 50 ? 2 * Math.sin(this.time.now / 500) : 0;
                    }
                } else {
                    bodyScaleY = 0.88;
                    bodyScaleX = 1.1;
                }

                // Body
                this.bunnyGraphics.fillStyle(0xD3D8DC, 1);
                this.bunnyGraphics.fillRoundedRect(-45 * bodyScaleX, -40 * bodyScaleY + hopHeight + breathingOffset, 90 * bodyScaleX, 70 * bodyScaleY, 25);
                this.bunnyGraphics.fillStyle(0xF8F9FA, 1);
                this.bunnyGraphics.fillRoundedRect(-40 * bodyScaleX, -35 * bodyScaleY + hopHeight + breathingOffset, 80 * bodyScaleX, 60 * bodyScaleY, 20);
                this.bunnyGraphics.lineStyle(1, 0xB0B7C0, 0.6);
                for (let x = -35; x <= 35; x += 10) {
                    this.bunnyGraphics.lineBetween(x * bodyScaleX, -25 * bodyScaleY + hopHeight + breathingOffset, x * bodyScaleX + 5, -15 * bodyScaleY + hopHeight + breathingOffset);
                }

                // Ears
                const earAngleBase = this.runSpeed !== 0 ? 12 * Math.sign(this.runSpeed) : 0;
                const earFlop = this.earFlopFrame === 1 && Math.abs(this.runSpeed) < 50 ? -25 : 0;
                const earAngleLeft = this.isCrouching ? earAngleBase + 10 : earAngleBase + earFlop;
                const earAngleRight = this.isCrouching ? earAngleBase + 10 : earAngleBase + earFlop;
                this.leftEarGraphics.setAngle(earAngleLeft);
                this.rightEarGraphics.setAngle(earAngleRight);
                this.leftEarGraphics.fillGradientStyle(0xF8F9FA, 0xE8ECEF, 0xF8F9FA, 0xE8ECEF, 1);
                this.leftEarGraphics.fillEllipse(-30, -70 + hopHeight, 20, 50);
                this.leftEarGraphics.fillStyle(0xFFC1CC, 1);
                this.leftEarGraphics.fillEllipse(-30, -70 + hopHeight, 14, 40);
                this.rightEarGraphics.fillGradientStyle(0xF8F9FA, 0xE8ECEF, 0xF8F9FA, 0xE8ECEF, 1);
                this.rightEarGraphics.fillEllipse(30, -68 + hopHeight, 20, 50);
                this.rightEarGraphics.fillStyle(0xFFC1CC, 1);
                this.rightEarGraphics.fillEllipse(30, -68 + hopHeight, 14, 40);

                // Tail
                const tailFlick = this.tailFlickFrame * 4 * (Math.abs(this.runSpeed) / 200 + 0.7);
                this.bunnyGraphics.fillGradientStyle(0xFFFFFF, 0xF8F9FA, 0xFFFFFF, 0xF8F9FA, 1);
                this.bunnyGraphics.fillCircle(-40 + tailFlick, 20 + hopHeight + breathingOffset, 18);
                this.bunnyGraphics.fillStyle(0xE8ECEF, 1);
                this.bunnyGraphics.fillCircle(-40 + tailFlick, 20 + hopHeight + breathingOffset, 14);

                // Legs
                const legHeightBase = this.isJumping ? 12 : this.isCrouching ? 8 : 28;
                const legHop = this.bunny.body.touching.down && !this.isCrouching ? 10 * Math.cos(this.hopPhase * 2 * Math.PI) : 0;
                this.bunnyGraphics.fillStyle(0xF8F9FA, 1);
                const legCycle = Math.floor(this.hopFrame / 1.5) % 6; // 6-phase hop
                const legPositions = [
                    { x1: -35, y1: 15, h1: legHeightBase + legHop, x2: 15, y2: 20, h2: legHeightBase + legHop - 5 }, // Push-off
                    { x1: -35, y1: 12, h1: legHeightBase + legHop + 5, x2: 15, y2: 18, h2: legHeightBase + legHop }, // Lift
                    { x1: 15, y1: 15, h1: legHeightBase + legHop, x2: -35, y2: 20, h2: legHeightBase + legHop - 5 }, // Peak
                    { x1: 15, y1: 12, h1: legHeightBase + legHop + 5, x2: -35, y2: 18, h2: legHeightBase + legHop }, // Descent
                    { x1: -35, y1: 18, h1: legHeightBase + legHop - 3, x2: 15, y2: 22, h2: legHeightBase + legHop - 7 }, // Land
                    { x1: 15, y1: 18, h1: legHeightBase + legHop - 3, x2: -35, y2: 22, h2: legHeightBase + legHop - 7 } // Recover
                ];
                const pos = legPositions[legCycle];
                this.bunnyGraphics.fillRoundedRect(pos.x1 * bodyScaleX, pos.y1 + hopHeight + breathingOffset, 20, pos.h1, 8);
                this.bunnyGraphics.fillRoundedRect(pos.x2 * bodyScaleX, pos.y2 + hopHeight + breathingOffset, 20, pos.h2, 8);

                // Face
                const eyeSize = Math.abs(this.runSpeed) > 50 ? 11 : 9;
                const eyeHeight = this.blinkFrame > 0 ? 3 : 9;
                this.bunnyGraphics.fillStyle(0x000000, 1);
                this.bunnyGraphics.fillEllipse(-20, -18 + hopHeight + breathingOffset, eyeSize, eyeHeight);
                this.bunnyGraphics.fillEllipse(20, -18 + hopHeight + breathingOffset, eyeSize, eyeHeight);
                if (!this.blinkFrame) {
                    this.bunnyGraphics.fillStyle(0xFFFFFF, 1);
                    this.bunnyGraphics.fillCircle(-19, -19 + hopHeight + breathingOffset, 3);
                    this.bunnyGraphics.fillCircle(21, -19 + hopHeight + breathingOffset, 3);
                }
                this.bunnyGraphics.fillStyle(0xFFC1CC, 1);
                const noseOffset = this.noseTwitchFrame ? 2 : 0;
                this.bunnyGraphics.fillTriangle(0, -6 + hopHeight + breathingOffset + noseOffset, -7, -3 + hopHeight + breathingOffset + noseOffset, 7, -3 + hopHeight + breathingOffset + noseOffset);
                this.bunnyGraphics.fillEllipse(0, -3 + hopHeight + breathingOffset + noseOffset, 14, 7);
                const whiskerSway = this.runSpeed / 60 + (this.noseTwitchFrame ? 0.5 : 0);
                this.bunnyGraphics.lineStyle(1, 0xFFFFFF, 0.9);
                this.bunnyGraphics.lineBetween(-14, -3 + hopHeight + breathingOffset, -35, -3 + whiskerSway + hopHeight + breathingOffset);
                this.bunnyGraphics.lineBetween(-14, 0 + hopHeight + breathingOffset, -33, 3 + whiskerSway + hopHeight + breathingOffset);
                this.bunnyGraphics.lineBetween(14, -3 + hopHeight + breathingOffset, 35, -3 + whiskerSway + hopHeight + breathingOffset);
                this.bunnyGraphics.lineBetween(14, 0 + hopHeight + breathingOffset, 33, 3 + whiskerSway + hopHeight + breathingOffset);

                // Dust trail
                if (Math.abs(this.runSpeed) > 100 && this.bunny.body.touching.down && this.hopPhase > 0.4 && this.hopPhase < 0.6) {
                    const dust = this.add.circle(this.bunny.x - 30 * Math.sign(this.runSpeed || 1), this.bunny.y + 30, 5, 0xA9A9A9, 0.4);
                    this.tweens.add({
                        targets: dust,
                        x: dust.x + Phaser.Math.Between(-20, 20),
                        y: dust.y - Phaser.Math.Between(10, 20),
                        alpha: 0,
                        duration: 300,
                        onComplete: () => dust.destroy()
                    });
                }
            }

            updateAnimations() {
                try {
                    if (this.bunny.body.touching.down && !this.isJumping && !this.isCrouching) {
                        const speedFactor = 1 + Math.abs(this.runSpeed) / this.speed; // Faster hops when running
                        this.hopFrame = (this.hopFrame + this.hopSpeed * speedFactor) % 6;
                        this.hopPhase = this.hopFrame / 6;
                        const tiltAngle = Math.abs(this.runSpeed) > 50 ? 10 * Math.sin(this.hopPhase * 2 * Math.PI) * Math.sign(this.runSpeed) : 5 * Math.sin(this.hopPhase * 2 * Math.PI);
                        this.bunny.angle = tiltAngle;
                    } else if (this.isJumping) {
                        this.bunny.angle = 25 * Math.sin(this.bunny.body.velocity.y / 250) * Math.sign(this.runSpeed || 1);
                    } else {
                        this.bunny.angle = 0;
                    }

                    this.blinkFrame = (this.time.now % 4500 < 80) ? 1 : 0;
                    this.noseTwitchFrame = (this.time.now % 2000 < 200) ? 1 : 0;
                    this.earFlopFrame = (this.time.now % 5000 < 300) ? 1 : 0;
                    this.tailFlickFrame = (this.time.now % 600 < 200) ? Phaser.Math.Between(1, 2) : 0;
                    this.updateBunnyGraphics();
                } catch (error) {
                    console.warn('Error updating animations:', error);
                }
            }

            moveRight() {
                if (this.bunny.body.touching.down && !this.isCrouching) {
                    this.bunny.body.setVelocityX(this.speed * 1.3); // Instant speed
                    this.bunny.scaleX = 1;
                    this.runSpeed = this.bunny.body.velocity.x;
                }
            }

            moveLeft() {
                if (this.bunny.body.touching.down && !this.isCrouching) {
                    this.bunny.body.setVelocityX(-this.speed * 1.3);
                    this.bunny.scaleX = -1;
                    this.runSpeed = this.bunny.body.velocity.x;
                }
            }

            initiateJump() {
                try {
                    if (this.bunny.body.touching.down || (this.time.now - this.lastGroundTime < this.coyoteTime)) {
                        if (!this.isCrouching) {
                            this.isCrouching = true;
                            this.crouchTime = this.time.now;
                            this.tweens.add({
                                targets: this.bunny,
                                scaleY: 0.75,
                                scaleX: 1.15,
                                duration: 80,
                                onComplete: () => {
                                    if (this.bunny && this.bunny.active) {
                                        this.performJump();
                                    }
                                }
                            });
                            // Tail flick anticipation
                            this.tailFlickFrame = 2;
                            this.updateBunnyGraphics();
                        }
                    }
                } catch (error) {
                    console.warn('Error initiating jump:', error);
                }
            }

            performJump() {
                try {
                    if (this.isCrouching && (this.bunny.body.touching.down || (this.time.now - this.lastGroundTime < this.coyoteTime))) {
                        const jumpVelocity = -950 - Math.abs(this.runSpeed) * 0.3;
                        this.bunny.body.setVelocityY(jumpVelocity);
                        this.isJumping = true;
                        this.isCrouching = false;
                        this.tweens.add({
                            targets: this.bunny,
                            scale: { x: 1.25, y: 0.85 },
                            angle: this.runSpeed > 0 ? 35 : -35,
                            duration: 180,
                            yoyo: true,
                            onComplete: () => {
                                if (this.bunny && this.bunny.active) {
                                    this.bunny.scale = 1;
                                    this.bunny.angle = 0;
                                }
                            }
                        });
                        const dust = this.add.graphics();
                        dust.fillStyle(0xA9A9A9, 0.6);
                        for (let i = 0; i < 12; i++) {
                            const dustParticle = this.add.circle(this.bunny.x + Phaser.Math.Between(-25, 25), this.bunny.y + 30, 4, 0xA9A9A9, 0.6);
                            this.tweens.add({
                                targets: dustParticle,
                                x: dustParticle.x + Phaser.Math.Between(-40, 40),
                                y: dustParticle.y + Phaser.Math.Between(10, 30),
                                alpha: 0,
                                duration: 350,
                                onComplete: () => {
                                    if (dustParticle && dustParticle.active) {
                                        dustParticle.destroy();
                                    }
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.warn('Error performing jump:', error);
                }
            }

            spawnObstacle() {
                try {
                    const obstacle = this.add.container(850, 500);
                    const stumpGraphics = this.add.graphics();
                    stumpGraphics.fillStyle(0x000000, 0.3);
                    stumpGraphics.fillEllipse(0, 40, 60, 10);
                    stumpGraphics.fillStyle(0x6B4E31, 1);
                    stumpGraphics.fillRoundedRect(-35, -60, 70, 100, 20);
                    stumpGraphics.lineStyle(2, 0x8B4513, 0.6);
                    for (let y = -50; y < 30; y += 10) {
                        stumpGraphics.lineBetween(-20, y, 20, y + 5);
                    }
                    stumpGraphics.fillStyle(0x228B22, 0.7);
                    stumpGraphics.fillEllipse(-25, -10, 15, 10);
                    stumpGraphics.fillEllipse(20, 0, 10, 8);
                    stumpGraphics.fillStyle(0x6B4E31, 1);
                    stumpGraphics.fillRect(30, -40, 20, 5);
                    this.tweens.add({
                        targets: stumpGraphics,
                        angle: 5,
                        duration: 500,
                        yoyo: true,
                        repeat: -1
                    });
                    obstacle.add(stumpGraphics);
                    obstacle.setSize(50, 90);
                    this.physics.add.existing(obstacle);
                    obstacle.body.setVelocityX(-200);
                    obstacle.body.setAllowGravity(false);

                    this.physics.add.overlap(this.bunny, obstacle, (bunny, obs) => {
                        if (!bunny || !obs || !bunny.active || !obs.active) return;
                        const collisionY = bunny.y + bunny.body.height / 2;
                        const obstacleTopY = obs.y - obs.body.height / 2;
                        if (collisionY > obstacleTopY + 30) {
                            this.gameOver();
                        }
                    }, null, this);

                    this.time.addEvent({
                        delay: 5000,
                        callback: () => {
                            if (obstacle && obstacle.active) {
                                obstacle.destroy();
                            }
                        },
                        callbackScope: this
                    });
                } catch (error) {
                    console.warn('Error spawning obstacle:', error);
                }
            }

            spawnCarrot() {
                try {
                    const carrot = this.add.container(850, Phaser.Math.Between(200, 400));
                    const carrotGraphics = this.add.graphics();
                    carrotGraphics.fillStyle(0xFFD700, 0.2);
                    carrotGraphics.fillEllipse(0, 0, 40, 40);
                    carrotGraphics.fillStyle(0xFF8C00, 1);
                    carrotGraphics.fillTriangle(0, -30, -15, 30, 15, 30);
                    carrotGraphics.lineStyle(1, 0xFFA500, 0.7);
                    for (let y = -20; y < 20; y += 5) {
                        carrotGraphics.lineBetween(-10, y, 10, y);
                    }
                    carrotGraphics.fillStyle(0x006400, 1);
                    carrotGraphics.fillTriangle(-12, -40, -7, -25, -2, -35);
                    carrotGraphics.fillTriangle(2, -40, 7, -25, 12, -35);
                    this.tweens.add({
                        targets: carrotGraphics,
                        angle: 3,
                        duration: 300,
                        yoyo: true,
                        repeat: -1
                    });
                    carrot.add(carrotGraphics);
                    carrot.setSize(30, 60);
                    this.physics.add.existing(carrot);
                    carrot.body.setVelocityX(-200);
                    carrot.body.setAllowGravity(false);

                    this.physics.add.overlap(this.bunny, carrot, () => {
                        this.collectCarrot(carrot);
                    }, null, this);

                    this.time.addEvent({
                        delay: 5000,
                        callback: () => {
                            if (carrot && carrot.active) {
                                carrot.destroy();
                            }
                        },
                        callbackScope: this
                    });
                } catch (error) {
                    console.warn('Error spawning carrot:', error);
                }
            }

            spawnPlatform() {
                try {
                    const x = 850;
                    const y = Phaser.Math.Between(300, 450);
                    const platform = this.add.container(x, y);
                    const platformGraphics = this.add.graphics();
                    platformGraphics.fillStyle(0x8B4513, 1);
                    platformGraphics.fillRect(-50, -20, 100, 40);
                    platformGraphics.lineStyle(2, 0xA0522D, 1);
                    platformGraphics.strokeRect(-50, -20, 100, 40);
                    platform.add(platformGraphics);
                    platform.setSize(100, 40);
                    this.physics.add.existing(platform);
                    platform.body.setVelocityX(-200);
                    platform.body.setImmovable(true);
                    this.platforms.add(platform);

                    this.time.addEvent({
                        delay: 6000,
                        callback: () => {
                            if (platform && platform.active) {
                                platform.destroy();
                            }
                        },
                        callbackScope: this
                    });
                } catch (error) {
                    console.warn('Error spawning platform:', error);
                }
            }

            spawnWall() {
                try {
                    const x = 850;
                    const height = Phaser.Math.Between(100, 200);
                    const y = 500 - height / 2;
                    const wall = this.add.container(x, y);
                    const wallGraphics = this.add.graphics();
                    wallGraphics.lineStyle(1, 0x000000, 0.3);
                    wallGraphics.fillStyle(0x8B4513, 1);
                    const brickHeight = 20;
                    const brickWidth = 40;
                    const wallWidth = 40;
                    for (let h = 0; h < height; h += brickHeight) {
                        const offset = (h / brickHeight % 2) * (brickWidth / 2);
                        for (let w = -wallWidth/2; w < wallWidth/2; w += brickWidth) {
                            wallGraphics.fillStyle(Phaser.Math.Between(0, 1) ? 0x8B4513 : 0x966F33, 1);
                            wallGraphics.fillRect(w + offset, h - height/2, brickWidth, brickHeight);
                            wallGraphics.strokeRect(w + offset, h - height/2, brickWidth, brickHeight);
                        }
                    }
                    wallGraphics.lineStyle(2, 0xFFFFFF, 0.2);
                    wallGraphics.lineBetween(-wallWidth/2, -height/2, -wallWidth/2, height/2);
                    wallGraphics.lineStyle(2, 0x000000, 0.2);
                    wallGraphics.lineBetween(wallWidth/2, -height/2, wallWidth/2, height/2);
                    wall.add(wallGraphics);
                    wall.setSize(wallWidth, height);
                    this.physics.add.existing(wall);
                    wall.body.setVelocityX(-200);
                    wall.body.setImmovable(true);
                    this.walls.add(wall);

                    this.time.addEvent({
                        delay: 6000,
                        callback: () => {
                            if (wall && wall.active) {
                                wall.destroy();
                            }
                        },
                        callbackScope: this
                    });
                } catch (error) {
                    console.warn('Error spawning wall:', error);
                }
            }

            collectCarrot(carrot) {
                if (!carrot || !carrot.active) return;

                const carrotX = carrot.x;
                const carrotY = carrot.y;
                carrot.destroy();

                this.carrots++;
                this.carrotText.setText('Carrots: ' + this.carrots);

                const sparkle = this.add.graphics();
                sparkle.setPosition(carrotX, carrotY);
                sparkle.fillStyle(0xFFD700, 1);
                const numParticles = 8;
                for (let i = 0; i < numParticles; i++) {
                    const angle = (i / numParticles) * Math.PI * 2;
                    const distance = Phaser.Math.Between(5, 15);
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;
                    sparkle.fillCircle(x, y, 3);
                }
                this.tweens.add({
                    targets: sparkle,
                    alpha: 0,
                    scale: 1.5,
                    duration: 500,
                    onComplete: () => {
                        if (sparkle && sparkle.active) {
                            sparkle.destroy();
                        }
                    }
                });

                try {
                    const tints = [
                        { carrots: 5, color: 0xFF6B6B },
                        { carrots: 10, color: 0x343A40 },
                        { carrots: 15, color: 0xFF8FAB }
                    ];
                    const tint = tints.find(t => t.carrots === this.carrots);
                    if (tint && this.bunnyGraphics && this.bunnyGraphics.active) {
                        this.bunnyGraphics.setTint(tint.color);
                        if (this.leftEarGraphics && this.leftEarGraphics.active) {
                            this.leftEarGraphics.setTint(tint.color);
                        }
                        if (this.rightEarGraphics && this.rightEarGraphics.active) {
                            this.rightEarGraphics.setTint(tint.color);
                        }
                    }
                } catch (error) {
                    console.warn('Error applying tint:', error);
                }
            }

            gameOver() {
                try {
                    this.physics.pause();
                    this.scene.start('GameOverScene', {
                        score: this.score,
                        carrots: this.carrots,
                        difficulty: this.difficulty
                    });
                } catch (error) {
                    console.warn('Error in gameOver:', error);
                }
            }

            update(time, delta) {
                try {
                    if (this.bunny.body.touching.down) {
                        this.lastGroundTime = time;
                    }

                    if (this.cursors.right.isDown && !this.isCrouching) {
                        this.moveRight();
                    } else if (this.cursors.left.isDown && !this.isCrouching) {
                        this.moveLeft();
                    } else {
                        this.bunny.body.setVelocityX(0);
                        this.runSpeed *= 0.85; // Smooth stop
                        if (Math.abs(this.runSpeed) < 20) this.runSpeed = 0;
                    }

                    this.bunny.body.velocity.x = Phaser.Math.Clamp(this.bunny.body.velocity.x, -this.speed * 1.5, this.speed * 1.5);

                    if (!this.bunny.body.touching.down) {
                        this.score += delta / 1000 * 10;
                        this.scoreText.setText('Score: ' + Math.floor(this.score));
                    } else if (this.isJumping) {
                        this.isJumping = false;
                        this.tweens.add({
                            targets: this.bunny,
                            y: this.bunny.y + 12,
                            scale: { x: 1.2, y: 0.8 },
                            duration: 90,
                            yoyo: true,
                            onComplete: () => {
                                if (this.bunny && this.bunny.active) {
                                    this.bunny.scale = 1;
                                }
                            }
                        });
                    }

                    this.groundOffset += 2;
                    this.hillsGraphics.x -= 0.5;
                    this.bushesGraphics.x -= 1;
                    if (this.hillsGraphics.x < -400) this.hillsGraphics.x += 800;
                    if (this.bushesGraphics.x < -400) this.bushesGraphics.x += 800;
                    this.drawGround();
                } catch (error) {
                    console.warn('Error in update:', error);
                }
            }
        }

        class IntroScene extends Phaser.Scene {
            constructor() {
                super({ key: 'IntroScene' });
            }

            create() {
                const skyGraphics = this.add.graphics();
                skyGraphics.fillGradientStyle(0x1a73e8, 0x174ea6, 0x174ea6, 0x1a73e8, 1);
                skyGraphics.fillRect(0, 0, 800, 600);

                for (let i = 0; i < 5; i++) {
                    const cloud = this.add.graphics();
                    cloud.fillStyle(0xffffff, 0.8);
                    const x = Phaser.Math.Between(0, 800);
                    const y = Phaser.Math.Between(50, 200);
                    cloud.fillCircle(x, y, 30);
                    cloud.fillCircle(x + 20, y - 10, 25);
                    cloud.fillCircle(x - 20, y - 5, 25);
                    this.tweens.add({
                        targets: cloud,
                        x: '+=20',
                        yoyo: true,
                        duration: 2000 + i * 500,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                }

                const bunny = this.add.graphics();
                bunny.setPosition(400, 200);
                bunny.fillStyle(0xFFFFFF, 1);
                bunny.fillCircle(0, 0, 40);
                bunny.fillCircle(-20, -50, 15);
                bunny.fillCircle(20, -50, 15);
                bunny.fillStyle(0xFF69B4, 1);
                bunny.fillCircle(-10, -10, 5);
                bunny.lineStyle(2, 0x000000, 1);
                bunny.strokeCircle(-20, -15, 8);
                bunny.strokeCircle(20, -15, 8);

                const titleGlow = this.add.text(400, 100, 'Bunny Hop', {
                    fontSize: '72px',
                    fontFamily: 'Arial Black',
                    color: '#fff',
                    stroke: '#4a90e2',
                    strokeThickness: 16,
                    shadow: { color: '#4a90e2', blur: 25, stroke: true, fill: true }
                }).setOrigin(0.5);

                const controlsBox = this.add.graphics();
                controlsBox.fillStyle(0x000000, 0.3);
                controlsBox.fillRoundedRect(200, 260, 400, 160, 20);

                const controls = [
                    'ðŸŽ® Controls',
                    '',
                    'âŒ¨ï¸ Space/Click - Jump',
                    'âŒ¨ï¸ Left/Right - Move',
                    '',
                    'ðŸ¥• Collect carrots for powers!'
                ].join('\n');

                this.add.text(400, 340, controls, {
                    fontSize: '24px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    align: 'center',
                    lineSpacing: 15
                }).setOrigin(0.5);

                const startButton = this.add.graphics();
                startButton.setPosition(400, 520);
                startButton.lineStyle(4, 0xFFFFFF, 1);
                startButton.fillStyle(0x0d47a1, 0.9);
                startButton.fillRoundedRect(-120, -30, 240, 60, 30);
                startButton.strokeRoundedRect(-120, -30, 240, 60, 30);

                const glowButton = this.add.graphics();
                glowButton.setPosition(400, 520);
                glowButton.lineStyle(8, 0xFFFFFF, 0.3);
                glowButton.strokeRoundedRect(-120, -30, 240, 60, 30);

                const startText = this.add.text(400, 520, 'TAP TO BEGIN', {
                    fontSize: '32px',
                    fontFamily: 'Arial Black',
                    color: '#fff',
                    stroke: '#1565c0',
                    strokeThickness: 6
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: glowButton,
                    alpha: { from: 0.1, to: 0.5 },
                    duration: 1200,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                this.tweens.add({
                    targets: [startButton, startText],
                    scaleX: 1.05,
                    scaleY: 1.05,
                    duration: 1200,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                startButton.setInteractive(new Phaser.Geom.Rectangle(-100, -25, 200, 50), Phaser.Geom.Rectangle.Contains);
                startText.setInteractive();

                const startGame = () => this.startGame();
                startButton.on('pointerdown', startGame);
                startText.on('pointerdown', startGame);

                startButton.on('pointerover', () => {
                    startButton.clear();
                    startButton.lineStyle(4, 0xFFFFFF, 1);
                    startButton.fillStyle(0x1565c0, 0.9);
                    startButton.fillRoundedRect(-120, -30, 240, 60, 30);
                    startButton.strokeRoundedRect(-120, -30, 240, 60, 30);
                    startText.setStyle({ stroke: '#1e88e5' });
                });

                startButton.on('pointerout', () => {
                    startButton.clear();
                    startButton.lineStyle(4, 0xFFFFFF, 1);
                    startButton.fillStyle(0x0d47a1, 0.9);
                    startButton.fillRoundedRect(-120, -30, 240, 60, 30);
                    startButton.strokeRoundedRect(-120, -30, 240, 60, 30);
                    startText.setStyle({ stroke: '#1565c0' });
                });

                this.input.on('pointerdown', () => this.startGame());
                this.input.keyboard.on('keydown-SPACE', () => this.startGame());
                this.input.keyboard.on('keydown-ENTER', () => this.startGame());
            }

            startGame() {
                this.scene.start('OptionsScene');
            }
        }

        class OptionsScene extends Phaser.Scene {
            constructor() {
                super({ key: 'OptionsScene' });
            }

            create() {
                const skyGraphics = this.add.graphics();
                skyGraphics.fillGradientStyle(0x1a73e8, 0x174ea6, 0x174ea6, 0x1a73e8, 1);
                skyGraphics.fillRect(0, 0, 800, 600);

                for (let i = 0; i < 5; i++) {
                    const cloud = this.add.graphics();
                    cloud.fillStyle(0xffffff, 0.8);
                    const x = Phaser.Math.Between(0, 800);
                    const y = Phaser.Math.Between(50, 200);
                    cloud.fillCircle(x, y, 30);
                    cloud.fillCircle(x + 20, y - 10, 25);
                    cloud.fillCircle(x - 20, y - 5, 25);
                    this.tweens.add({
                        targets: cloud,
                        x: '+=20',
                        yoyo: true,
                        duration: 2000 + i * 500,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                }

                this.add.text(400, 100, 'Select Difficulty', {
                    fontSize: '48px',
                    fontFamily: 'Arial Black',
                    color: '#fff',
                    stroke: '#4a90e2',
                    strokeThickness: 12,
                    shadow: { color: '#4a90e2', blur: 20, stroke: true, fill: true }
                }).setOrigin(0.5);

                const container = this.add.graphics();
                container.fillStyle(0x000000, 0.3);
                container.fillRoundedRect(200, 180, 400, 400, 20);

                const difficulties = [
                    { level: 1, name: 'Easy Hop', color: 0x4CAF50, desc: 'Perfect for beginners' },
                    { level: 2, name: 'Normal Bounce', color: 0x2196F3, desc: 'Standard challenge' },
                    { level: 3, name: 'Hard Jump', color: 0xFFC107, desc: 'For skilled players' },
                    { level: 4, name: 'Expert Leap', color: 0xFF5722, desc: 'Intense challenge' },
                    { level: 5, name: 'Master Spring', color: 0x9C27B0, desc: 'Ultimate test' }
                ];

                difficulties.forEach((diff, index) => {
                    const y = 230 + index * 70;
                    const buttonBg = this.add.graphics();
                    buttonBg.setPosition(400, y);
                    buttonBg.lineStyle(3, 0xFFFFFF, 0.8);
                    buttonBg.fillStyle(diff.color, 0.2);
                    buttonBg.fillRoundedRect(-160, -25, 320, 50, 15);
                    buttonBg.strokeRoundedRect(-160, -25, 320, 50, 15);

                    const text = this.add.text(400, y - 10, diff.name, {
                        fontSize: '24px',
                        fontFamily: 'Arial Black',
                        color: '#fff',
                        stroke: '#000',
                        strokeThickness: 4
                    }).setOrigin(0.5);

                    const descText = this.add.text(400, y + 15, diff.desc, {
                        fontSize: '16px',
                        fontFamily: 'Arial',
                        color: '#ccc'
                    }).setOrigin(0.5);

                    buttonBg.setInteractive(new Phaser.Geom.Rectangle(-160, -25, 320, 50), Phaser.Geom.Rectangle.Contains)
                        .on('pointerover', () => {
                            buttonBg.clear();
                            buttonBg.lineStyle(3, 0xFFFFFF, 1);
                            buttonBg.fillStyle(diff.color, 0.4);
                            buttonBg.fillRoundedRect(-160, -25, 320, 50, 15);
                            buttonBg.strokeRoundedRect(-160, -25, 320, 50, 15);
                            text.setScale(1.05);
                            descText.setScale(1.05);
                        })
                        .on('pointerout', () => {
                            buttonBg.clear();
                            buttonBg.lineStyle(3, 0xFFFFFF, 0.8);
                            buttonBg.fillStyle(diff.color, 0.2);
                            buttonBg.fillRoundedRect(-160, -25, 320, 50, 15);
                            buttonBg.strokeRoundedRect(-160, -25, 320, 50, 15);
                            text.setScale(1);
                            descText.setScale(1);
                        })
                        .on('pointerdown', () => this.startGame(diff.level));
                });
            }

            startGame(difficulty) {
                this.cameras.main.fade(500, 0, 0, 0);
                this.time.delayedCall(500, () => {
                    this.scene.start('GameScene', { difficulty });
                });
            }
        }

        class GameOverScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameOverScene' });
            }

            init(data) {
                this.score = data.score;
                this.carrots = data.carrots;
                this.difficulty = data.difficulty;
            }

            create() {
                const skyGraphics = this.add.graphics();
                skyGraphics.fillGradientStyle(0x87CEEB, 0x87CEEB, 0xE0FFFF, 0xE0FFFF, 1);
                skyGraphics.fillRect(0, 0, 800, 600);

                this.add.text(400, 150, 'Game Over!', {
                    fontSize: '64px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    stroke: '#000',
                    strokeThickness: 6,
                    shadow: { color: '#000', blur: 10, stroke: true, fill: true }
                }).setOrigin(0.5);

                this.add.text(400, 250, `Score: ${Math.floor(this.score)}\nCarrots: ${this.carrots}`, {
                    fontSize: '32px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    stroke: '#000',
                    strokeThickness: 4,
                    align: 'center',
                    lineSpacing: 10
                }).setOrigin(0.5);

                const buttonStyle = {
                    fontSize: '32px',
                    fontFamily: 'Arial',
                    color: '#fff',
                    stroke: '#000',
                    strokeThickness: 4,
                    backgroundColor: '#4CAF50',
                    padding: { x: 20, y: 10 }
                };

                const replayButton = this.add.text(400, 350, 'Replay Level', buttonStyle)
                    .setOrigin(0.5)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => replayButton.setScale(1.1))
                    .on('pointerout', () => replayButton.setScale(1))
                    .on('pointerdown', () => {
                        this.scene.start('GameScene', { difficulty: this.difficulty });
                    });

                const quizButton = this.add.text(400, 420, 'Try Different Level', buttonStyle)
                    .setOrigin(0.5)
                    .setInteractive({ useHandCursor: true })
                    .on('pointerover', () => quizButton.setScale(1.1))
                    .on('pointerout', () => quizButton.setScale(1))
                    .on('pointerdown', () => {
                        this.scene.start('OptionsScene');
                    });
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            backgroundColor: '#87CEEB',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false,
                    tileBias: 40,
                    fps: 60
                }
            },
            scene: [IntroScene, OptionsScene, GameScene, GameOverScene]
        };

        new Phaser.Game(config);
    </script>
</body>
</html>
